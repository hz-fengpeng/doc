1. IP header 是20个字节，IP body 部分数据是可变长度，最多 65515字节
2. 加密，也只是加密了 body 的部分，不会把 header 也加密，如果加密了header 就无法解析。举个例子，如果一个加密套件是用在 TCP 层的，那这个加密套件只会加密 TCP body 里面的数据，中间的路由器窃取流量，还是能看到 TCP 的header，知道双方通信的端口号
3. 我们比较常见的 HTTPS 协议，HTTPS 是用在 TLS 协议，作用在 TCP 层，所以HTTPS 会对 TCP body进行加密，但是TCP header 不加密。
4. IP 头部里面的 协议（8位）代表 IP body 里面是哪个协议的数据，如果是 06 ，IP body 里面就是 TCP 的数据
5. 上图这个字段如果是 17，那IP body 里面的就是 UDP 的数据。所有协议都是这样搞的，在header里面插个 type 类型，表示 body 里面是什么数据，一个协议套一个协议地套下去。
6. 上图的 * 代表没有 ICMP 返回 ，所以不知道IP数据包在哪个路由器 TTL变成0了。是否返回 ICMP 告诉 TTL 过期 不是强制性的，有些路由器就是不返回 ICMP，直接丢弃TTL等于 0的数据。
7. 多数情况下，TCP服务器是并发的，UDP的服务器是迭代的
8. 所以基于 IP 层的协议，想要在广域网上实现可靠传输，都需要自己实现一套 ACK 机制，TCP 自带 ACK，UDT 协议是自己实现 ACK。
9. TCP 应用早期有 C10k 问题，但是运营商的 NAT 硬件防火墙，要处理的 TCP 链接，肯定超过10k，他是怎么解决的？修改 linux 内核，或者不用linux内核，把硬件性能压榨到极致。TCP 标准只是定义了 TCP 的行为，没有强制一定要像 linux 内核那样跟文件系统通用数据结构。可以自行实现 TCP 的行为，符合标准就行。
10. TCP 协议由于无法及时感知当前的链路不通，，所以需要上层协议实现心跳来 快速 知道底层链路通信是否正常。所以 心跳可以让应用层尽快知道底层链路 有问题，尽快切换服务器。或者跟原来的服务器重新建立链接。
11. wraparound，回环处理。seq 跟ack 是在滑动窗口机制下 同步递增的，他们之间的差距不会超过     2^(32-1) - 1。
12. 网络字节序就是大端字节序, 我们编程时候经常用的 inet_addr() , htons()，干的活，就是把 TCP 的header ，UDP 的header 转成大端字节序，再发送
13. TCP 使用的 MTU 发现，是通过 3次握手，发送双方的MSS来实现。发送的MSS是结合自己网卡的MTU跟ARP路由表的信息计算出来的。因为 MTU 是MAC 层的最小传输单元，如果超过 MTU，IP层就会分片。分片有什么坏处？会降低传输效率。MTU 是MAC 层限制的，是最小传输单元。MAC 层的body最多能放 1500 字节.Path MTU Discover （路径MTU发现机制），可以使用 ICMP PTB 消息来实现
14. 这个路径MTU发现逻辑是这样的，如果路由器发现 IP包 的DF 位设置为1，就不能分片，会返回一个 ICMP PTB 包给发送端，这个 ICMP PTB 有那个路由器的MTU。
UDP scoket怎么拿到这个 ICMP PTB 数据，具体我还要找找接口，应该是有的。
TCP 是内部自己处理了 ICMP PTB 数据，在内核处理。
补充：ICMP PTB 的MTU应该会更新到 本机的路由表，TCP 读路由表数据实现动态调整 MSS。这样实现了不同协议层的功能解耦
15. IP 层的分片对于 TCP，UDP 来说是透明的，也就是说，你用 TCP socket，UDP socket 是感受不到这个分片的。
16. UDP 的一个缺点，UDP 不像 TCP ，TCP 内部有一个算法，会找出传输路径中最小的MTU，然后基于这个 MTU 进行切分，避免在 IP 层分片，因为如果在 IP 层分片，一个IP分片丢失，会导致整一块数据重新传输。